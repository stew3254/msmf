package main

import (
  "bufio"
  "database/sql"
  "fmt"
  "encoding/base64"
  "github.com/gorilla/websocket"
  //"github.com/mattn/go-sqlite3"
  "golang.org/x/crypto/bcrypt"
  "log"
  "os"
  "net/http"
  _ "github.com/mattn/go-sqlite3"
)

var upgrader = websocket.Upgrader{
  ReadBufferSize:  2048,
  WriteBufferSize: 2048,
}

type User struct {
  username string
  password string
  password_hash string
}

//Takes a password and returns the base64 encoded hash
func hash(password *string) (string, error) {
  //Default cost of hash
  cost := 10
  password_hash, err := bcrypt.GenerateFromPassword([]byte(*password), cost)
  if err != nil {
    return "", nil
  }
  encoded := base64.StdEncoding.EncodeToString([]byte(password_hash))
  return encoded, nil
}

func create_db() {
  database, err := sql.Open("sqlite3", "msmf.db")
  if err != nil {
    fmt.Println(err)
  }
  //Create the users table
  statement, err := database.Prepare("CREATE TABLE IF NOT EXISTS 'users' ('uuid' INTEGER AUTO_INCREMENT PRIMARY KEY, 'username' TEXT NOT NULL UNIQUE, 'password' TEXT NOT NULL)")
  if err != nil {
    fmt.Println(err)
  }
  statement.Exec()

  //Prepare to insert the administrator user into the db
  statement, err = database.Prepare("INSERT INTO users ('uuid', 'username', 'password') VALUES (?, ?, ?)")
  if err != nil {
    fmt.Println(err)
  }

  //Ask user for the password
  scanner := bufio.NewScanner(os.Stdin)
  scanner.Scan()
  password := scanner.Text()
  encoded_password, err := hash(&password)
  if err != nil {
    fmt.Println(err)
  }

  statement.Exec("0", "Administrator", encoded_password)
}

func register(w http.ResponseWriter, r *http.Request) {
  defer r.Body.Close()
  if r.Method == "POST" {
    r.ParseForm()

    //Create the user
    var user User
    confirm_password := ""

    //Look through the map
    for key, value := range r.Form {
      if key == "username" {
        user.username = value[0]
      } else if key == "password" {
        user.password = value[0]
      } else if key == "confirm" {
        confirm_password = value[0]
      }

      //Stop looking if we don't need to
      if user.username != "" && user.password != "" && confirm_password != "" {
        break
      }
    }
    if user.password != confirm_password {
      fmt.Println("Passwords do not match")
    } else {
      password_hash, err := hash(&user.password)
      user.password_hash = password_hash
      if err != nil {
        fmt.Println(err)
      }

      database, err := sql.Open("sqlite3", "msmf.db")
      if err != nil {
        fmt.Println(err)
      }

      statement, err := database.Prepare("INSERT INTO Users (username, name) VALUES (?,?)")
      if err != nil {
        fmt.Println(err)
      }
      statement.Exec(user.username, user.password_hash)
      fmt.Println("Added user", user.username)
    }
  }
  //Make sure the login page gets served correctly
  http.ServeFile(w, r, "./static/register.html")
}

//Handles login posts
func login(w http.ResponseWriter, r *http.Request) {
  defer r.Body.Close()
  if r.Method == "POST" {
    r.ParseForm()

    //Create the user
    var user User

    //Look through the map
    for key, value := range r.Form {
      if key == "username" {
        user.username = value[0]
      } else if key == "password" {
        user.password = value[0]
      }

      //Stop looking if we don't need to
      if user.username != "" && user.password != "" {
        break
      }
    }

    //Hash the password and then add the username and hashed password to the struct
    if user.username != "" && user.password != "" {
      password_hash, err := hash(&user.password)
      user.password_hash = password_hash
      if err != nil {
        fmt.Println(err)
      }
      database, err := sql.Open("sqlite3", "msmf.db")
      if err != nil {
        fmt.Println(err)
      }
      defer database.Close()

      rows, err := database.Query("SELECT username, password FROM users where username=?", user.username)
      if err != nil {
        fmt.Println(err)
      }

      defer rows.Close()
      in_db := false
      for rows.Next() {
        username := ""
        hash := make([]byte, 60)
        err:=rows.Scan(&username, &hash)
        if err != nil {
          fmt.Println(err)
        }

        if username == user.username {
          in_db = true;
          if bcrypt.CompareHashAndPassword(hash, []byte(user.password)) == nil {
            fmt.Println("Login successful")
          } else {
            fmt.Println("Login unsuccessful")
          }
        }
      }

      if !in_db {
        fmt.Println("Not in db")
      }

      err = rows.Err()
      if err != nil {
        fmt.Println(err)
      }
    }
  }

  //Make sure the login page gets served correctly
  http.ServeFile(w, r, "./static/login.html")
}

func ws_handler(w http.ResponseWriter, r *http.Request) {
  //Upgrade the http connection
  conn, err := upgrader.Upgrade(w, r, nil)
  if err != nil {
    fmt.Println(err)
    return
  }
  for {
    messageType, p, err := conn.ReadMessage()
    if err != nil {
      fmt.Println(err)
      return
    }

    fmt.Println(string(p))
    err = conn.WriteMessage(messageType, []byte("Message from the server!"))

    if err != nil {
      fmt.Println(err)
      return
    }
  }
}

func main() {
  create_db()
  http.Handle("/", http.FileServer(http.Dir("./static")))
  http.HandleFunc("/login", login)
  http.HandleFunc("/register", register)
  http.HandleFunc("/websocket", ws_handler)
  log.Fatal(http.ListenAndServe(":8080", nil))
}
